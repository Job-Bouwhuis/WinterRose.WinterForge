using System.Text;

namespace WinterRose.WinterForgeSerializing.Factory;

public sealed class WinterForgeFactory
{
    private readonly List<Node> nodes = new();
    private readonly Dictionary<object, ObjectHandle> objectCache = new();
    private readonly Dictionary<int, Node> nodeById = new();

    private int idCounter = 0;
    private Handle? rootHandle;
    private bool built = false;

    public WinterForgeFactory()
    {
    }

    private int NextId()
    {
        return idCounter++;
    }

    public ObjectHandle DefineType(Type type)
    {
        EnsureNotBuilt();
        int id = NextId();
        var node = new ObjectNode(id, type);
        nodes.Add(node);
        nodeById.Add(id, node);
        var handle = new ObjectHandle(id, node, type);
        return handle;
    }

    public ListHandle DefineList(Type elementType)
    {
        EnsureNotBuilt();
        int id = NextId();
        var node = new ListNode(id, elementType);
        nodes.Add(node);
        nodeById.Add(id, node);
        var handle = new ListHandle(id, node, elementType);
        return handle;
    }

    public MapHandle DefineMap(Type keyType, Type valueType)
    {
        EnsureNotBuilt();
        int id = NextId();
        var node = new MapNode(id, keyType, valueType);
        nodes.Add(node);
        nodeById.Add(id, node);
        var handle = new MapHandle(id, node, keyType, valueType);
        return handle;
    }

    public void SetRoot(Handle handle)
    {
        EnsureNotBuilt();
        rootHandle = handle;
    }

    public void SetRoot(ObjectHandle handle)
    {
        EnsureNotBuilt();
        rootHandle = handle;
    }

    public string Build()
    {
        using var ms = new MemoryStream();
        Build(ms);
        ms.Position = 0;
        using var reader = new StreamReader(ms, Encoding.UTF8, true);
        return reader.ReadToEnd();
    }

    public void Build(Stream stream)
    {
        EnsureNotBuilt();
        built = true;

        using var writer = new StreamWriter(stream, Encoding.UTF8, 8192, leaveOpen: true);

        // Header
        writer.WriteLine($"// Generated by WinterForge {DateTime.UtcNow:yyyy.MM.dd.HH.mm}");
        // Emit nodes in id order
        foreach (var node in nodes.OrderBy(n => n.Id))
        {
            EmitNode(node, writer);
        }

        // Emit root return if defined
        if (rootHandle is not null)
        {
            writer.WriteLine($"return {GetReturnValueForRoot(rootHandle)}");
        }
        else
        {
            writer.WriteLine("return 0");
        }

        writer.Flush();
    }

    private string GetReturnValueForRoot(Handle handle)
    {
        // follow the WinterForge convention of returning numeric id if root is numeric id
        return "0";
    }

    private void EmitNode(Node node, StreamWriter writer)
    {
        switch (node)
        {
            case ObjectNode on:
                EmitObjectNode(on, writer);
                break;
            case ListNode ln:
                EmitListNode(ln, writer);
                break;
            case MapNode mn:
                EmitMapNode(mn, writer);
                break;
            default:
                throw new InvalidOperationException($"Unknown node type: {node.GetType().FullName}");
        }
    }

    private void EmitObjectNode(ObjectNode obj, StreamWriter writer)
    {
        string typeName = obj.ObjectType.FullName ?? obj.ObjectType.Name;
        writer.WriteLine($"{typeName} : {obj.Id} {{");
        foreach (var member in obj.Members)
        {
            writer.Write($"{Indent(1)}{member.Name} = ");
            EmitValueNode(member.Value, writer, 1);
            writer.WriteLine(";");
        }
        writer.WriteLine("}");
    }

    private void EmitListNode(ListNode list, StreamWriter writer)
    {
        string elemTypeName = list.ElementType.FullName ?? list.ElementType.Name;
        writer.WriteLine($"{Indent(0)}<{elemTypeName}>[");
        foreach (var elem in list.Elements)
        {
            writer.Write(Indent(1));
            EmitValueNode(elem, writer, 1);
            writer.WriteLine();
        }
        writer.WriteLine("]");
    }

    private void EmitMapNode(MapNode map, StreamWriter writer)
    {
        string keyType = map.KeyType.FullName ?? map.KeyType.Name;
        string valType = map.ValueType.FullName ?? map.ValueType.Name;
        writer.WriteLine($"{Indent(0)}<{keyType}, {valType}>[");
        foreach (var entry in map.Entries)
        {
            writer.Write(Indent(1));
            EmitValueNode(entry.Key, writer, 1);
            writer.Write(" => ");
            EmitValueNode(entry.Value, writer, 1);
            writer.WriteLine();
        }
        writer.WriteLine("]");
    }

    private void EmitValueNode(ValueNode value, StreamWriter writer, int depth)
    {
        switch (value)
        {
            case PrimitiveValueNode p:
                writer.Write(EmitPrimitive(p.Value));
                break;
            case ReferenceValueNode r:
                writer.Write($"#ref({r.Target.Id})");
                break;
            case InlineObjectValueNode i:
                EmitInlineObject(i.Object, writer, depth);
                break;
            default:
                throw new InvalidOperationException($"Unknown value node type: {value.GetType().FullName}");
        }
    }

    private void EmitInlineObject(ObjectNode obj, StreamWriter writer, int depth)
    {
        string typeName = obj.ObjectType.FullName ?? obj.ObjectType.Name;
        writer.Write($"{typeName} {{");
        if (obj.Members.Count > 0)
        {
            writer.WriteLine();
            foreach (var member in obj.Members)
            {
                writer.Write($"{Indent(depth + 1)}{member.Name} = ");
                EmitValueNode(member.Value, writer, depth + 1);
                writer.WriteLine(";");
            }
            writer.Write($"{Indent(depth)}");
        }
        writer.Write("}");
    }

    private string EmitPrimitive(object? value)
    {
        if (value is null)
            return "null";
        if (value is string s)
            return $"\"{EscapeString(s)}\"";
        if (value is bool b)
            return b ? "True" : "False";
        if (value is char c)
            return $"'{EscapeChar(c)}'";
        if (value is DateTime dt)
            return $"\"{dt:o}\"";
        if (value is Enum e)
            return e.ToString();
        // numbers and other primitives
        return Convert.ToString(value, System.Globalization.CultureInfo.InvariantCulture) ?? "null";
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static string EscapeChar(char c)
    {
        if (c == '\'' ) return "\\'";
        if (c == '\\') return "\\\\";
        return c.ToString();
    }

    private static string Indent(int depth)
    {
        return new string('\t', depth);
    }

    private void EnsureNotBuilt()
    {
        if (built)
            throw new InvalidOperationException("Factory has already been built.");
    }

    // Convenience helpers to create ValueNodes from runtime values
    public static ValueNode ValueFrom(object? value)
    {
        if (value is Handle h)
            return new ReferenceValueNode(h);
        if (value is ObjectNode on)
            return new InlineObjectValueNode(on);
        return new PrimitiveValueNode(value);
    }
}